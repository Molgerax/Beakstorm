#pragma kernel FlushDamage
#pragma kernel Clear
#pragma kernel CollideBoids

#include "../SpatialGrid/SpatialGridSampling.hlsl"
#include "ImpactUtility.hlsl"
#include "SdfUtility.hlsl"

#define THREAD_GROUP_SIZE 16


StructuredBuffer<AbstractSdfData> _WeakPointBuffer;
RWStructuredBuffer<int> _DamageBuffer;
StructuredBuffer<int> _FlushDamageBuffer;

int _WeakPointCount;
int _BufferSize;
float _Time;
float _DeltaTime;


[numthreads(THREAD_GROUP_SIZE,1,1)]
void FlushDamage(uint3 id : SV_DispatchThreadID)
{
    int index = id.x;

    if (index >= _BufferSize)
        return;

    if (index >= _WeakPointCount)
    {
        _DamageBuffer[index] = 0;
        return;
    }
    
    int flushDamage = _FlushDamageBuffer[index];
    int dmg = _DamageBuffer[index] - flushDamage;

    if (flushDamage >= 10000)
        dmg = 0;
    
    _DamageBuffer[index] = max(0, dmg);
}

[numthreads(THREAD_GROUP_SIZE,1,1)]
void Clear(uint3 id : SV_DispatchThreadID)
{
    int index = id.x;

    if (index >= _WeakPointCount)
        return;

    _DamageBuffer[index] = 0;
}


StructuredBuffer<float3> _PositionBuffer;
StructuredBuffer<float3> _OldPositionBuffer;


struct Boid
{
    float3 pos;
    float exposure;
    float3 oldPos;
    float data;
    float4 rotation;
};

StructuredBuffer<Boid> _BoidBuffer;
StructuredBuffer<uint> _GridOffsetBuffer;

float lineSphereIntersection(float3 p1, float3 p2, float3 p3, float r)
{
    float3 d = p2 - p1;
    float a = dot(d, d);
    float b = 2 * dot(d, p1 - p3);
    float c = dot(p3, p3) + dot(p1, p1) - 2 * dot(p3, p1) - r * r;
    return b * b - 4 * a * c;
}

[numthreads(THREAD_GROUP_SIZE,1,1)]
void CollideBoids(uint3 id : SV_DispatchThreadID)
{
    int index = id.x;

    if (index >= _WeakPointCount)
        return;

    if (_DeltaTime == 0)
    {
        return;
    }
    
    AbstractSdfData sdfData = _WeakPointBuffer.Load(index);
    float3 positionA = sdfData.Translate;
    float radius = sdfData.Data.x + 2;

    radius = 50;

    if (sdfData.Data.x == 0)
    {
        _DamageBuffer[index] = 0;
        return;
    }
    
    float3 minimum, maximum;
    bbGeneric(sdfData, minimum, maximum);

    positionA = (maximum + minimum) / 2;
    radius = largestElement(maximum - minimum);

    uint3 cellDimensions = _CellDimensions;

    int3 cellMin = GetGridCellId(minimum, _HashCellSize, _SimulationCenter, _SimulationSize);
    int3 cellMax = GetGridCellId(maximum, _HashCellSize, _SimulationCenter, _SimulationSize);
    int3 sideLengths = cellMax - cellMin + 1;
    
    for(int iterator = 0; iterator < sideLengths.x * sideLengths.y * sideLengths.z; iterator++)
    {
        int3 cellId = GetGridCellIdFromBounds(cellMin, cellMax, iterator);
        
        uint key = KeyFromCellId(cellId, cellDimensions);
        uint currIndex = _GridOffsetBuffer[key-1];
        uint nextIndex = _GridOffsetBuffer[key+0];
    
        while (currIndex < nextIndex)
        {
            Boid boid = _BoidBuffer[currIndex];
            currIndex++;
 
            float3 offset = boid.pos - positionA;

            SdfQueryInfo info = sdfGeneric(boid.pos, sdfData);
            SdfQueryInfo oldInfo = sdfGeneric(boid.oldPos, sdfData);

            if (info.dist > 0)
                continue;
            
            float3 velocity = (boid.pos - boid.oldPos) / _DeltaTime;
            
            if (oldInfo.dist > 0)
            {
                uint damage = CalculateDamage(velocity);
                _DamageBuffer[index] += damage;
                
                float dist = length(offset);
                if (dist == 0)
                    continue;

                float3 norm = info.normal;
                AddImpact(boid.pos + norm * info.dist, norm, damage);
            }
        }
    }
}
